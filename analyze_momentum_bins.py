#!/usr/bin/env python3
"""
Momentum-bin based c2{2} analysis for TMC simulations.
Loads pre-generated data from generate_sr_data.py and performs binned analysis.

This script analyzes the data from sr_training_data.csv which contains:
- Multiple temperature values (T = 0.15, 0.20, 0.25, 0.30, 0.35 GeV)
- Multiplicity range N = 3-50
- Binned c2{2} correlations for all bin combinations

Usage:
    python analyze_momentum_bins.py [--temperature T]
"""

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path

# =============================================================================
# Configuration
# =============================================================================

# Input data path (generated by generate_sr_data.py)
INPUT_DATA_PATH = Path("data/sr_training_data.csv")

# pT bin boundaries (GeV) - same as generate_sr_data.py
PT_MIN_CUT = 0.3  # Minimum pT cut (GeV)
PT_BINS = [0.3, 0.5, 0.8, np.inf]
BIN_LABELS = ['low', 'mid', 'high']

# Output paths
OUTPUT_DIR = Path("data")
FIG_DIR = Path("figs")


# =============================================================================
# Utility Functions (used by generate_sr_data.py)
# =============================================================================

def get_quantile_bin_edges(T: float, n_bins: int = 3,
                           pt_min: float = PT_MIN_CUT) -> list:
    """
    Compute T-dependent bin edges using equal-probability quantiles of the
    truncated Boltzmann distribution (p >= pt_min).

    The momentum distribution is Gamma(k=2, scale=T). We condition on
    p >= pt_min and split the remaining probability mass into n_bins
    equal slices.

    Args:
        T: Temperature (GeV)
        n_bins: Number of bins (default 3)
        pt_min: Minimum pT cut (GeV)

    Returns:
        List of n_bins+1 bin edges, e.g. [pt_min, q1, q2, inf]
    """
    from scipy.stats import gamma as gamma_dist

    dist = gamma_dist(a=2, scale=T)
    F_min = dist.cdf(pt_min)

    edges = [pt_min]
    for k in range(1, n_bins):
        # k-th quantile of the truncated distribution
        F_k = F_min + k / n_bins * (1.0 - F_min)
        edges.append(dist.ppf(F_k))
    edges.append(np.inf)

    return edges


def assign_bins(pT: np.ndarray, bin_edges: list) -> np.ndarray:
    """
    Assign particles to pT bins.

    Particles below the minimum pT cut (first bin edge) are assigned bin index -1
    and should be excluded from analysis.

    Args:
        pT: Array of shape (n_samples, N) - transverse momentum magnitudes
        bin_edges: List of bin boundaries [0.3, 0.5, 0.8, inf]

    Returns:
        bin_indices: Array of shape (n_samples, N) with bin index (0, 1, 2)
                     or -1 for particles below minimum pT cut
    """
    bin_idx = np.digitize(pT, bin_edges[1:-1])
    bin_idx = np.where(pT < bin_edges[0], -1, bin_idx)
    return bin_idx


def calculate_exact_c2_binned(N: int, T: float,
                               p1_min: float, p1_max: float,
                               p2_min: float, p2_max: float) -> float:
    """
    Calculate exact c2{2} for specific momentum bin ranges using numerical integration.

    The exact formula integrates the Bessel function ratio I_2/I_0 over the
    specified momentum ranges.

    Note: <p²>_F = 6T² is used because the TMC constraint involves ALL N particles
    (including those below pT_min), not just the ones we analyze.

    Args:
        N: Number of particles
        T: Temperature (GeV)
        p1_min, p1_max: Momentum range for particle 1 (bin_i)
        p2_min, p2_max: Momentum range for particle 2 (bin_j)

    Returns:
        Exact c2{2} value for this bin combination
    """
    from scipy.special import i0, iv
    from scipy.integrate import dblquad

    # <p²>_F for full Boltzmann distribution (Gamma(2,T))
    # This is correct because TMC constraint involves ALL particles, not just analyzed ones
    mean_p2_F = 6 * T**2
    coeff = 2 / ((N - 2) * mean_p2_F)

    def pdf(p):
        return (p / T**2) * np.exp(-p / T)

    def numerator(p2, p1):
        x = coeff * p1 * p2
        return iv(2, x) * pdf(p1) * pdf(p2)

    def denominator(p2, p1):
        x = coeff * p1 * p2
        return i0(x) * pdf(p1) * pdf(p2)

    p1_upper = min(p1_max, 20 * T)
    p2_upper = min(p2_max, 20 * T)
    opts = {'epsabs': 1e-6, 'epsrel': 1e-6}

    try:
        num_val, _ = dblquad(numerator, p1_min, p1_upper,
                              lambda x: p2_min, lambda x: p2_upper, **opts)
        den_val, _ = dblquad(denominator, p1_min, p1_upper,
                              lambda x: p2_min, lambda x: p2_upper, **opts)
        if den_val > 0:
            return num_val / den_val
        else:
            return np.nan
    except Exception:
        return np.nan


# =============================================================================
# Data Loading Functions
# =============================================================================

def load_sr_data(input_path: Path = INPUT_DATA_PATH) -> pd.DataFrame:
    """
    Load pre-generated SR training data from CSV.

    Args:
        input_path: Path to sr_training_data.csv

    Returns:
        DataFrame with all temperature and multiplicity combinations
    """
    if not input_path.exists():
        raise FileNotFoundError(
            f"Data file not found: {input_path}\n"
            f"Please run 'python generate_sr_data.py' first to generate the data."
        )

    df = pd.read_csv(input_path)
    print(f"Loaded {len(df)} data points from {input_path}")
    print(f"  Temperature values: {sorted(df['T'].unique())} GeV")
    print(f"  Multiplicity range: N = {df['N'].min()} - {df['N'].max()}")

    return df


def prepare_analysis_data(df: pd.DataFrame, T: float = None) -> pd.DataFrame:
    """
    Prepare data for analysis by filtering temperature and adding derived columns.

    Args:
        df: Raw DataFrame from sr_training_data.csv
        T: Temperature to filter (if None, analyze all temperatures)

    Returns:
        Processed DataFrame with c2_err, c2_approx columns added
    """
    # Filter by temperature if specified
    if T is not None:
        available_temps = sorted(df['T'].unique())
        if T not in available_temps:
            raise ValueError(
                f"Temperature T={T} not found in data.\n"
                f"Available temperatures: {available_temps}"
            )
        df = df[df['T'] == T].copy()
        print(f"Filtered to T = {T} GeV: {len(df)} data points")
    else:
        df = df.copy()

    # Rename c2_std to c2_err for compatibility with plotting functions
    if 'c2_std' in df.columns and 'c2_err' not in df.columns:
        df['c2_err'] = df['c2_std']

    # Calculate c2_approx from mean_p1_sq, mean_p2_sq, N, T
    # Formula: c2{2} = <p1^2> * <p2^2> / (2 * (N-2)^2 * (6*T^2)^2)
    df['c2_approx'] = df.apply(
        lambda row: calculate_approximation_c2_binned(
            row['mean_p1_sq'], row['mean_p2_sq'], row['N'], row['T']
        ),
        axis=1
    )

    # Add sqrt_c2 column
    df['sqrt_c2'] = np.sqrt(np.abs(df['c2_mean']))
    df['bin_pair'] = df['bin_i'] + '_' + df['bin_j']

    return df


def calculate_approximation_c2_binned(mean_p1_sq: float, mean_p2_sq: float,
                                       N: int, T: float) -> float:
    """
    Calculate the approximation c2{2} for a bin combination.

    Formula: c2{2} = <p1^2>_Omega * <p2^2>_Omega / (2 * (N-2)^2 * <p^2>_F^2)

    Args:
        mean_p1_sq: <p^2>_Omega for bin 1
        mean_p2_sq: <p^2>_Omega for bin 2
        N: Number of particles
        T: Temperature (GeV)

    Returns:
        Approximate c2{2} value
    """
    if np.isnan(mean_p1_sq) or np.isnan(mean_p2_sq):
        return np.nan

    # <p^2>_F = 6*T^2 for Gamma(2, T) distribution
    mean_p2_F = 6 * T**2

    # Approximation formula
    c2_approx = (mean_p1_sq * mean_p2_sq) / (2.0 * (N - 2)**2 * mean_p2_F**2)

    return c2_approx


# =============================================================================
# Visualization Functions
# =============================================================================

def plot_c2_vs_N(df: pd.DataFrame, T: float, output_dir: Path):
    """
    Create 1D projections: c2{2}(N) for each bin combination.

    Creates a 3x3 subplot grid showing c2 vs N for all 9 bin combinations,
    comparing simulation with exact theory and approximation formula.

    Args:
        df: DataFrame with binned results (already filtered by temperature)
        T: Temperature (GeV)
        output_dir: Directory to save figure
    """
    n_bins = len(BIN_LABELS)

    fig, axes = plt.subplots(n_bins, n_bins, figsize=(12, 10), sharex=True)

    for i, bin_i in enumerate(BIN_LABELS):
        for j, bin_j in enumerate(BIN_LABELS):
            ax = axes[i, j]

            # Filter data
            mask = (df['bin_i'] == bin_i) & (df['bin_j'] == bin_j)
            df_subset = df[mask].sort_values('N')

            N = df_subset['N'].values
            c2 = df_subset['c2_mean'].values
            err = df_subset['c2_err'].values
            c2_approx = df_subset['c2_approx'].values
            c2_exact = df_subset['c2_exact'].values

            # Plot simulation c2
            ax.errorbar(N, c2, yerr=err, fmt='ko', markersize=4, capsize=2,
                        label='Sim')

            # Plot exact theory
            ax.plot(N, c2_exact, 'b-', linewidth=1.5, label='Exact')

            # Plot approximation formula
            ax.plot(N, c2_approx, 'r--', linewidth=1.5, label='Approx')

            ax.axhline(0, color='gray', linestyle=':', alpha=0.5)

            # Labels
            ax.set_title(f'{bin_i}-{bin_j}', fontsize=10, fontweight='bold')
            if i == n_bins - 1:
                ax.set_xlabel('N')
            if j == 0:
                ax.set_ylabel(r'$c_2\{2\}$')

            ax.grid(True, alpha=0.3)

            if i == 0 and j == n_bins - 1:
                ax.legend(fontsize=7, loc='upper right')

    fig.suptitle(rf'Binned $c_2\{{2\}}$ at T={T} GeV: Simulation vs Exact vs Approximation',
                 fontsize=11, y=1.02)
    fig.tight_layout()
    # Include temperature in filename
    T_str = f"{T:.2f}".replace('.', 'p')
    fig.savefig(output_dir / f'c2_vs_N_binned_T{T_str}.png', dpi=300, bbox_inches='tight')
    plt.close(fig)
    print(f"  Saved c2 vs N projection plot for T={T}")


def plot_c2_comparison(df: pd.DataFrame, T: float, output_dir: Path):
    """
    Compare all bin combinations: Simulation vs Exact vs Approximation.

    Args:
        df: DataFrame with binned results (already filtered by temperature)
        T: Temperature (GeV)
        output_dir: Directory to save figure
    """
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))

    colors = plt.cm.tab10(np.linspace(0, 1, 9))

    # Left plot: Simulation results
    ax = axes[0]
    color_idx = 0
    for bin_i in BIN_LABELS:
        for bin_j in BIN_LABELS:
            mask = (df['bin_i'] == bin_i) & (df['bin_j'] == bin_j)
            df_subset = df[mask].sort_values('N')

            N = df_subset['N'].values
            c2 = df_subset['c2_mean'].values
            err = df_subset['c2_err'].values

            label = f'{bin_i}-{bin_j}'
            ax.errorbar(N, c2, yerr=err, fmt='o-', markersize=3, capsize=2,
                        label=label, color=colors[color_idx], alpha=0.8)
            color_idx += 1

    ax.axhline(0, color='gray', linestyle=':', alpha=0.5)
    ax.set_xlabel('N (Multiplicity)')
    ax.set_ylabel(r'$c_2\{2\}$')
    ax.set_title(f'Simulation (T={T} GeV)')
    ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', fontsize=7)
    ax.grid(True, alpha=0.3)

    # Middle plot: Exact theory
    ax = axes[1]
    color_idx = 0
    for bin_i in BIN_LABELS:
        for bin_j in BIN_LABELS:
            mask = (df['bin_i'] == bin_i) & (df['bin_j'] == bin_j)
            df_subset = df[mask].sort_values('N')

            N = df_subset['N'].values
            c2_exact = df_subset['c2_exact'].values

            label = f'{bin_i}-{bin_j}'
            ax.plot(N, c2_exact, 'o-', markersize=3,
                    label=label, color=colors[color_idx], alpha=0.8)
            color_idx += 1

    ax.axhline(0, color='gray', linestyle=':', alpha=0.5)
    ax.set_xlabel('N (Multiplicity)')
    ax.set_ylabel(r'$c_2\{2\}$ (Exact)')
    ax.set_title(r'Exact: $\int I_2/I_0$ over bin')
    ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', fontsize=7)
    ax.grid(True, alpha=0.3)

    # Right plot: Approximation formula
    ax = axes[2]
    color_idx = 0
    for bin_i in BIN_LABELS:
        for bin_j in BIN_LABELS:
            mask = (df['bin_i'] == bin_i) & (df['bin_j'] == bin_j)
            df_subset = df[mask].sort_values('N')

            N = df_subset['N'].values
            c2_approx = df_subset['c2_approx'].values

            label = f'{bin_i}-{bin_j}'
            ax.plot(N, c2_approx, 'o-', markersize=3,
                    label=label, color=colors[color_idx], alpha=0.8)
            color_idx += 1

    ax.axhline(0, color='gray', linestyle=':', alpha=0.5)
    ax.set_xlabel('N (Multiplicity)')
    ax.set_ylabel(r'$c_2\{2\}$ (Approx)')
    ax.set_title(r'Approx: $\frac{\langle p_1^2 \rangle \langle p_2^2 \rangle}{2(N-2)^2 \langle p^2 \rangle_F^2}$')
    ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', fontsize=7)
    ax.grid(True, alpha=0.3)

    fig.tight_layout()
    # Include temperature in filename
    T_str = f"{T:.2f}".replace('.', 'p')
    fig.savefig(output_dir / f'c2_comparison_all_bins_T{T_str}.png', dpi=300, bbox_inches='tight')
    plt.close(fig)
    print(f"  Saved comparison plot for T={T}")


# =============================================================================
# Main Execution
# =============================================================================

def analyze_temperature(df_all: pd.DataFrame, T: float, fig_dir: Path):
    """
    Run analysis for a single temperature value.

    Args:
        df_all: Full DataFrame with all temperatures
        T: Temperature to analyze (GeV)
        fig_dir: Directory to save figures
    """
    print(f"\n{'='*70}")
    print(f"Analyzing T = {T} GeV")
    print(f"{'='*70}")

    # Prepare data for this temperature
    df = prepare_analysis_data(df_all, T=T)

    if df.empty:
        print(f"  Warning: No data for T={T}")
        return None

    print(f"  N range: {df['N'].min()} - {df['N'].max()}")
    print(f"  Data points: {len(df)}")

    # Generate plots
    print("\n  Generating visualizations...")

    available_N = sorted(df['N'].unique())

    # 1D projections
    plot_c2_vs_N(df, T, fig_dir)

    # Comparison plot
    plot_c2_comparison(df, T, fig_dir)

    # Print sample results
    sample_N = 30 if 30 in available_N else available_N[len(available_N)//2]
    print(f"\n  Sample c2{{2}} values at N={sample_N}:")
    df_sample = df[df['N'] == sample_N][['bin_i', 'bin_j', 'c2_mean', 'c2_exact', 'c2_approx']]
    print(df_sample.to_string(index=False))

    return df


def main():
    """Main entry point for binned c2{2} analysis."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description='Analyze binned c2{2} from pre-generated SR training data.'
    )
    parser.add_argument(
        '-T', '--temperature', type=float, default=None,
        help='Temperature to analyze (GeV). If not specified, analyze all temperatures.'
    )
    parser.add_argument(
        '-i', '--input', type=str, default=str(INPUT_DATA_PATH),
        help=f'Input CSV file path (default: {INPUT_DATA_PATH})'
    )
    args = parser.parse_args()

    print("=" * 70)
    print("Momentum-Bin Based c2{2} Analysis")
    print("(Using pre-generated data from generate_sr_data.py)")
    print("=" * 70)

    # Load data
    print("\n[Phase 1] Loading data...")
    input_path = Path(args.input)
    df_all = load_sr_data(input_path)

    # Get available temperatures
    available_temps = sorted(df_all['T'].unique())
    print(f"\nMinimum pT cut: {PT_MIN_CUT} GeV (particles below excluded)")
    print(f"pT bins: {PT_BINS} -> labels: {BIN_LABELS}")
    print(f"  - {BIN_LABELS[0]}: {PT_BINS[0]:.1f} - {PT_BINS[1]:.1f} GeV")
    print(f"  - {BIN_LABELS[1]}: {PT_BINS[1]:.1f} - {PT_BINS[2]:.1f} GeV")
    print(f"  - {BIN_LABELS[2]}: {PT_BINS[2]:.1f}+ GeV")

    # Create output directories
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    FIG_DIR.mkdir(parents=True, exist_ok=True)

    # Set plotting style
    try:
        plt.style.use(['science', 'nature'])
    except Exception:
        plt.style.use('default')
        print("  (Using default plot style - scienceplots not available)")

    # Analyze
    print("\n[Phase 2] Running analysis...")

    if args.temperature is not None:
        # Analyze single temperature
        if args.temperature not in available_temps:
            print(f"\nError: Temperature T={args.temperature} not in data.")
            print(f"Available temperatures: {available_temps}")
            return None
        temperatures_to_analyze = [args.temperature]
    else:
        # Analyze all temperatures
        temperatures_to_analyze = available_temps

    results = {}
    for T in temperatures_to_analyze:
        results[T] = analyze_temperature(df_all, T, FIG_DIR)

    # Print summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    print(f"\nAnalyzed temperatures: {temperatures_to_analyze}")
    print(f"\nOutput figures saved to: {FIG_DIR}/")

    # List generated figures
    T_str_list = [f"{T:.2f}".replace('.', 'p') for T in temperatures_to_analyze]
    for T_str in T_str_list:
        matching_files = list(FIG_DIR.glob(f'*T{T_str}*.png'))
        if matching_files:
            print(f"\n  T={T_str.replace('p', '.')} GeV:")
            for fig_file in sorted(matching_files):
                print(f"    - {fig_file.name}")

    print("\nDone!")
    return results


if __name__ == "__main__":
    main()
